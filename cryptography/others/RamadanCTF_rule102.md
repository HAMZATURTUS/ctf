# RamadanCTF - Rule 102

Category: Cryptography

Difficulty: Easy

## Source

<img width="340" height="329" alt="image" src="https://github.com/user-attachments/assets/e38240ac-8659-4319-9f9f-6f8f036f202d" />

### chall.py:

```py
from Crypto.Util.number import *

FLAG = b"REDACTED"
rule = 102
size = len(FLAG) * 8
pt = bytes_to_long(FLAG)
pt = list(bin(pt)[2:].zfill(size))

def gen_key(seed):
    states = [bin(i)[2:].zfill(3) for i in range(8)][::-1]
    transitions = {state : i for state, i in zip(states, bin(rule)[2:].zfill(8))}
    new_row = seed
    for _ in range(size):
        curr = ["0"] + new_row + ["0"]
        new_row = [transitions["".join(curr[i-1:i+2])] for i in range(1, 1 + len(seed))]
        
    return new_row

def xor(l1, l2):
    return [str(int(i) ^ int(j)) for i, j in zip(l1, l2)]

if __name__ == "__main__":
    x1, x2 = getRandomNBitInteger(size), getRandomNBitInteger(size)
    s1, s2 = list(bin(x1)[2:].zfill(size)), list(bin(x2)[2:].zfill(size)) 
    k1, k2 = gen_key(s1), gen_key(s2)
    ct = "".join(xor(xor(k1, k2), pt))
    hint = "".join(xor(s2, s1)[:-10])
    print("ct:", ct)
    print("hint", hint)
    
"""
ct: 11111101000110100111010000110001001001111110001001111101001010101000000010111110110100000001111101100101001100011110010111111111001101011001111100111000011000001110100000001101011101011011100010001111010010010111100101110100000000110011101101101010000010010011010100111100010110000111100111001100101010100111000011001101010010001110010010110011011000101111101000001100110001111000001001110101101001111110111010101111
hint 0001010001001110000001011111000011100111110110010101000010110011000100110010001101011110001111110001101111101101110111000101010101101100110010100101001110000100011011000110100100011000100011110100100010010000000100111111001110000000000001011000011111010010011110100010111100111101010110010011101010110011111010111001001110101001001100111111110100110010100000001011000001100100000011110001110011010011110100

"""
```

The challenge generated two random numbers each 416 bits in length (same length as the given ct), converted them into lists of their own bits, then ran them through gen_key(). The result of both gen_key()’s are xored and used as a key to encrypt the plaintext by xor.

gen_key() generates a dictionary called transitions based on the value rule

```py
rule = 01100110
transitions = {'111': '0', '110': '1', '101': '1', '100': '0', '011': '0', '010': '1', '001': '1', '000': '0'}
```

Notice that rule is symmetric when represented in binary so each key in the transitions dictionary will have the same value as its negation

```py
transitions['111'] = transitions['000'] = '0'
transitions['101'] = transitions['010'] = '1'
```

Transitions is used in some loop that continually changes new_row based on each 3 consecutive bits inside it. After the loop is done, the final new_row is returned.

## Solution

The code may seem really big and scary but xor has many properties that can make this very easy to solve. Such properties can be found either by doing some research or by experimenting with your own script. I opted for the second option and came across this realization:

```py
x = getRandomNBitInteger(size)
x = list(bin(x)[2:].zfill(size))
y = getRandomNBitInteger(size)
y = list(bin(y)[2:].zfill(size))

t1 = xor(gen_key(x), gen_key(y))
t2 = gen_key(xor(x, y))

print(t1 == t2) # always printed true
```

This snippet has proven that given two numbers x and y, performing { gen_key(x), genkey(y) } → xor() gave the same value as xor(x, y) → gen_key(). The two steps can be done in any order and this is very helpful because even though the original key was generated by using gen_key() first, the hint we have access to has been xored first. So performing gen_key(hint) should give the original key.

The challenge has been made a bit harder by the removal of the last 10 bits of hint. This can be bypassed with a little brute force.

```py
from Crypto.Util.number import long_to_bytes


def gen_key(seed):
    states = [bin(i)[2:].zfill(3) for i in range(8)][::-1]
    transitions = {state : i for state, i in zip(states, bin(rule)[2:].zfill(8))}
    new_row = seed
    for _ in range(size):
        curr = ["0"] + new_row + ["0"]
        new_row = [transitions["".join(curr[i-1:i+2])] for i in range(1, 1 + len(seed))]
        
    return new_row

def xor(l1, l2):
    return [str(int(i) ^ int(j)) for i, j in zip(l1, l2)]


rule = 102
size = 416

ct = "11111101000110100111010000110001001001111110001001111101001010101000000010111110110100000001111101100101001100011110010111111111001101011001111100111000011000001110100000001101011101011011100010001111010010010111100101110100000000110011101101101010000010010011010100111100010110000111100111001100101010100111000011001101010010001110010010110011011000101111101000001100110001111000001001110101101001111110111010101111"
hint = "0001010001001110000001011111000011100111110110010101000010110011000100110010001101011110001111110001101111101101110111000101010101101100110010100101001110000100011011000110100100011000100011110100100010010000000100111111001110000000000001011000011111010010011110100010111100111101010110010011101010110011111010111001001110101001001100111111110100110010100000001011000001100100000011110001110011010011110100"

my_states = [bin(i)[2:].zfill(10) for i in range(1024)][::-1] # generate all possible 10 bit numbers to add back to the hint
for add in my_states:
    seed = hint + add
    seed = list(seed)
    
    key = gen_key(seed) # the original key was made by gen_key -> xor. this key is generated by xor -> gen_key. both will lead to the same result
    flag = xor(key, list(ct))
    
    flag = "".join(flag) # list -> string
    flag = long_to_bytes(int(flag, 2))
    
    
    if b'Ramadan' in flag:
        print(flag)
```

## Flag

```
Ramadan{if_it_exists_then_there_is_a_*flag*_for_it?}
```
